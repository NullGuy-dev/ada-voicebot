{
  "data": [
    {"tag": "code", "patterns": ["print()", "a = 2        b = 3        print(a + b)", "x = 5        print(x ** 2)", "n = 5        factorial = 1        for i in range(1, n+1):            factorial *= i        print(factorial)", "n = 10        a, b = 0, 1        while a < n:            print(a)            a, b = b, a+b", "s = 'hello'        print(s[::-1])", "n = 7        for i in range(2, n):            if n % i == 0:                print()                break        else:            print()", "s = 'racecar'        if s == s[::-1]:            print()        else:            print()", "numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]        numbers.sort()        print(numbers)", "numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]        print(sum(numbers))", "import sysfrom PyQt5.QtCore import *from PyQt5.QtGui import *from PyQt5.QtWidgets import *from PyQt5.QtWebEngineWidgets import *class Browser(QMainWindow):    def __init__(self):        super().__init__()        self.setWindowTitle('Python Browser')        self.browser = QWebEngineView()        self.browser.setUrl(QUrl('https://www.google.com'))        self.setCentralWidget(self.browser)        self.showMaximized()app = QApplication(sys.argv)browser = Browser()sys.exit(app.exec_())", "def parse_data(data_string):    data_list = data_string.split(',')    parsed_data = []    for data in data_list:        data = data.strip()        if data.isdigit():            parsed_data.append(int(data))        elif '.' in data:            try:                parsed_data.append(float(data))            except ValueError:                parsed_data.append(data)        elif data.lower() == 'true':            parsed_data.append(True)        elif data.lower() == 'false':            parsed_data.append(False)        else:            parsed_data.append(data)    return parsed_data", "import pygamepygame.init()screen_width = 800screen_height = 600screen = pygame.display.set_mode((screen_width, screen_height))pygame.display.set_caption('Python Drawing Program')black = (0, 0, 0)white = (255, 255, 255)red = (255, 0, 0)green = (0, 255, 0)blue = (0, 0, 255)brush_color = blackbrush_size = 5brush_shape = 'circle'running = Truewhile running:    for event in pygame.event.get():        if event.type == pygame.QUIT:            running = False        elif event.type == pygame.MOUSEBUTTONDOWN:            pos = pygame.mouse.get_pos()            if brush_shape == 'circle':                pygame.draw.circle(screen, brush_color, pos, brush_size)            elif brush_shape == 'rectangle':                pygame.draw.rect(screen, brush_color, (pos[0], pos[1], brush_size, brush_size))            elif brush_shape == 'line':                pygame.draw.line(screen, brush_color, pos, (pos[0]+brush_size, pos[1]+brush_size), brush_size)    pygame.display.update()pygame.quit()", "import pygamefrom pygame.locals import *from OpenGL.GL import *from OpenGL.GLU import *vertices = (    (1, -1, -1),    (1, 1, -1),    (-1, 1, -1),    (-1, -1, -1),    (1, -1, 1),    (1, 1, 1),    (-1, -1, 1),    (-1, 1, 1))edges = (    (0, 1),    (0, 3),    (0, 4),    (2, 1),    (2, 3),    (2, 7),    (6, 3),    (6, 4),    (6, 7),    (5, 1),    (5, 4),    (5, 7))def Cube():    glBegin(GL_LINES)    for edge in edges:        for vertex in edge:            glVertex3fv(vertices[vertex])    glEnd()def main():    pygame.init()    display = (800, 600)    pygame.display.set_mode(display, DOUBLEBUF|OPENGL)    gluPerspective(45, (display[0]/display[1]), 0.1, 50.0)    glTranslatef(0.0, 0.0, -5)    while True:        for event in pygame.event.get():            if event.type == pygame.QUIT:                pygame.quit()                quit()        keys = pygame.key.get_pressed()        if keys[pygame.K_w]:            glTranslatef(0,0,0.1)        if keys[pygame.K_s]:            glTranslatef(0,0,-0.1)        if keys[pygame.K_a]:            glTranslatef(0.1,0,0)        if keys[pygame.K_d]:            glTranslatef(-0.1,0,0)        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)        Cube()        pygame.display.flip()        pygame.time.wait(10)if __name__ == '__main__':    main()", "import tkinter as tkimport pickleclass Task:    def __init__(self, description, is_done=False):        self.description = description        self.is_done = is_doneclass TodoList:    def __init__(self):        self.tasks = []    def add_task(self, description):        self.tasks.append(Task(description))    def remove_task(self, index):        del self.tasks[index]    def mark_task_done(self, index):        self.tasks[index].is_done = True    def mark_task_undone(self, index):        self.tasks[index].is_done = False    def get_task_list(self):        return [(task.description, task.is_done) for task in self.tasks]class App:    def __init__(self, master):        self.master = master        master.title(\"Todo List\")        self.todo_list = TodoList()        self.task_entry = tk.Entry(master, width=30)        self.add_button = tk.Button(master, text=\"Add\", command=self.add_task)        self.task_listbox = tk.Listbox(master, width=40, height=10)        self.delete_button = tk.Button(master, text=\"Delete\", command=self.delete_task)        self.mark_done_button = tk.Button(master, text=\"Mark Done\", command=self.mark_task_done)        self.mark_undone_button = tk.Button(master, text=\"Mark Undone\", command=self.mark_task_undone)        self.task_entry.grid(row=0, column=0, padx=5, pady=5)        self.add_button.grid(row=0, column=1, padx=5, pady=5)        self.task_listbox.grid(row=1, column=0, columnspan=2, padx=5, pady=5)        self.delete_button.grid(row=2, column=0, padx=5, pady=5)        self.mark_done_button.grid(row=2, column=1, padx=5, pady=5)        self.mark_undone_button.grid(row=3, column=1, padx=5, pady=5)        try:            with open(\"todo_list.pkl\", \"rb\") as f:                self.todo_list = pickle.load(f)        except FileNotFoundError:            pass        self.update_task_listbox()    def add_task(self):        task_description = self.task_entry.get()        self.todo_list.add_task(task_description)        self.task_entry.delete(0, \"end\")        self.update_task_listbox()    def delete_task(self):        selected_index = self.task_listbox.curselection()        if selected_index:            self.todo_list.remove_task(selected_index[0])            self.update_task_listbox()    def mark_task_done(self):        selected_index = self.task_listbox.curselection()        if selected_index:            self.todo_list.mark_task_done(selected_index[0])            self.update_task_listbox()    def mark_task_undone(self):        selected_index = self.task_listbox", "import randomdef generate_password(length):    characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()_+\"    password = \"\"    for i in range(length):        password += random.choice(characters)    return passwordpassword = generate_password(12)print(password)", "import requestsfrom bs4 import BeautifulSoupimport pandas as pdimport redef get_page_data(url):    response = requests.get(url)    soup = BeautifulSoup(response.content, 'html.parser')    product_title = soup.find(id='productTitle').get_text().strip()    current_price = soup.find(id='priceblock_ourprice').get_text().strip()    current_price = float(re.sub(r'[^\\d.]+', '', current_price))    rating = soup.find('span', {'class': 'a-icon-alt'}).get_text().strip()    reviews = soup.find('span', {'id': 'acrCustomerReviewText'}).get_text().strip()    reviews = int(re.sub(r'[^\\d]+', '', reviews))    data = {        'Product Title': product_title,        'Price': current_price,        'Rating': rating,        'Number of Reviews': reviews,        'URL': url    }    return datadef get_product_urls():    response = requests.get('https://www.amazon.com/s?k=laptop')    soup = BeautifulSoup(response.content, 'html.parser')    product_links = soup.find_all('a', {'class': 'a-link-normal s-no-outline'})    urls = []    for link in product_links:        url = 'https://www.amazon.com' + link['href']        urls.append(url)    return urlsdef main():    urls = get_product_urls()    product_data = []    for url in urls:        data = get_page_data(url)        product_data.append(data)    df = pd.DataFrame(product_data)    df.to_csv('amazon_products.csv', index=False)if __", "import telegramfrom telegram.ext import Updater, CommandHandler, MessageHandler, Filters# Токен бота Telegram, полученный у BotFatherTOKEN = 'your_bot_token_here'# Создаем объект Updater и передаем ему токен ботаupdater = Updater(TOKEN)# Получаем объект Dispatcher для регистрации обработчиков событийdispatcher = updater.dispatcher# Функция-обработчик команды /startdef start(update, context):    context.bot.send_message(chat_id=update.effective_chat.id, text=\"Привет, я бот! Чем я могу помочь?\")# Функция-обработчик текстовых сообщенийdef echo(update, context):    context.bot.send_message(chat_id=update.effective_chat.id, text=update.message.text)# Функция-обработчик файловdef send_file(update, context):    file_id = update.message.document.file_id    file_name = update.message.document.file_name    context.bot.send_document(chat_id=update.effective_chat.id, document=file_id, filename=file_name)# Регистрируем обработчики событийdispatcher.add_handler(CommandHandler('start', start))dispatcher.add_handler(MessageHandler(Filters.text, echo))dispatcher.add_handler(MessageHandler(Filters.document, send_file))# Запускаем ботаupdater.start_polling()", "import requestsimport osfrom bs4 import BeautifulSoupfrom urllib.parse import urljoin, urlparse# Создаем класс FlickrCrawlerclass FlickrCrawler:    def __init__(self, query, max_images):        self.query = query        self.max_images = max_images        self.headers = {            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}        self.url = 'https://www.flickr.com/search/?q=' + query    def download_images(self, save_directory):        page_count = 1        image_count = 0        while image_count < self.max_images:            print('Searching page', page_count)            page_url = self.url + '&page=' + str(page_count)            page_content = requests.get(page_url, headers=self.headers).content            soup = BeautifulSoup(page_content, 'html.parser')            image_links = soup.find_all('a', {'class': 'overlay'})            for link in image_links:                if image_count >= self.max_images:                    break                image_url = link.get('href')                if image_url.startswith('/photos'):                    image_page_url = urljoin('https://www.flickr.com', image_url)                    image_page_content = requests.get(image_page_url, headers=self.headers).content                    soup = BeautifulSoup(image_page_content, 'html.parser')                    image_src = soup.find('img', {'class': 'main-photo'}).get('src')                    image_filename = urlparse(image_src).path.split('/')[-1]                    image_path = os.path.join(save_directory, image_filename)                    if not os.path.exists(image_path):                        print('Downloading', image_src)                        with open(image_path, 'wb') as f:                            f.write(requests.get(image_src).content)                        image_count += 1                    else:                        print('Skipping', image_src)            page_count += 1# Используем FlickrCrawler для скачивания изображений с сайта Flickrif __name__ == '__main__':    query = input('Введите запрос: ')    max_images = int(input('Введите количество изображений, которое нужно скачать: '))    save_directory = input('Введите директорию для сохранения изображений: ')    crawler = FlickrCrawler(query, max_images)    crawler.download_images(save_directory)    print('Скачивание завершено!')", "import sqlite3def create_table():    conn = sqlite3.connect('example.db')    c = conn.cursor()    c.execute('''CREATE TABLE IF NOT EXISTS employees                (id INTEGER PRIMARY KEY,                name TEXT,                position TEXT,                salary REAL)''')    conn.commit()    conn.close()def add_employee(name, position, salary):    conn = sqlite3.connect('example.db')    c = conn.cursor()    c.execute(\"INSERT INTO employees (name, position, salary) VALUES (?, ?, ?)\", (name, position, salary))    conn.commit()    conn.close()def view_employees():    conn = sqlite3.connect('example.db')    c = conn.cursor()    c.execute(\"SELECT * FROM employees\")    rows = c.fetchall()    conn.close()    return rowsdef delete_employee(id):    conn = sqlite3.connect('example.db')    c = conn.cursor()    c.execute(\"DELETE FROM employees WHERE id=?\", (id,))    conn.commit()    conn.close()def update_employee(id, name, position, salary):    conn = sqlite3.connect('example.db')    c = conn.cursor()    c.execute(\"UPDATE employees SET name=?, position=?, salary=? WHERE id=?\", (name, position, salary, id))    conn.commit()    conn.close()create_table()add_employee(\"John Smith\", \"Manager\", 5000.0)add_employee(\"Jane Doe\", \"Assistant\", 3500.0)update_employee(1, \"John Doe\", \"CEO\", 10000.0)delete_employee(2)print(view_employees())", "import tkinter as tkfrom tkinter import ttkimport sqlite3from datetime import datetimeimport matplotlib.pyplot as pltclass BudgetApp:    def __init__(self):        self.window = tk.Tk()        self.window.title(\"Учет расходов\")        self.window.geometry(\"800x600\")                # соединяемся с базой данных        self.conn = sqlite3.connect('budget.db')        self.cursor = self.conn.cursor()                # создаем таблицу расходов, если она не существует        self.cursor.execute('''CREATE TABLE IF NOT EXISTS expenses                            (id INTEGER PRIMARY KEY AUTOINCREMENT,                            amount REAL,                            category TEXT,                            date TEXT)''')        self.conn.commit()                # создаем элементы интерфейса        self.create_widgets()                # запускаем главный цикл приложения        self.window.mainloop()                    def create_widgets(self):        # создаем вкладки        self.tabControl = ttk.Notebook(self.window)        self.expensesTab = ttk.Frame(self.tabControl)        self.statTab = ttk.Frame(self.tabControl)        self.goalTab = ttk.Frame(self.tabControl)        self.tabControl.add(self.expensesTab, text=\"Расходы\")        self.tabControl.add(self.statTab, text=\"Статистика\")        self.tabControl.add(self.goalTab, text=\"Цели\")        self.tabControl.pack(expand=1, fill=\"both\")                # создаем элементы на вкладке расходов        self.expenseAmountLabel = tk.Label(self.expensesTab, text=\"Сумма расхода:\")        self.expenseAmountLabel.pack()        self.expenseAmountEntry = tk.Entry(self.expensesTab)        self.expenseAmountEntry.pack()                self.expenseCategoryLabel = tk.Label(self.expensesTab, text=\"Категория расхода:\")        self.expenseCategoryLabel.pack()        self.expenseCategoryEntry = tk.Entry(self.expensesTab)        self.expenseCategoryEntry.pack()                self.expenseDateLabel = tk.Label(self.expensesTab, text=\"Дата расхода (в формате дд.мм.гггг):\")        self.expenseDateLabel.pack()        self.expenseDateEntry = tk.Entry(self.expensesTab)        self.expenseDateEntry.pack()                self.addExpenseButton = tk.Button(self.expensesTab, text=\"Добавить расход\", command=self", "import pandas as pdimport numpy as npimport yfinance as yffrom sklearn.linear_model import LinearRegressionfrom sklearn.metrics import mean_squared_errorimport matplotlib.pyplot as plt# Список фондовых индексов для анализаindexes = ['^GSPC', '^DJI', '^IXIC', '^RUT']# Загрузка данных о котировках индексов из Yahoo Financedata = yf.download(indexes, start='2010-01-01', end='2022-04-29')['Adj Close']# Проверка на наличие пропущенных значенийif data.isnull().values.any():    data = data.dropna()# Рассчет доходности индексовreturns = data.pct_change()# Рассчет еженедельных доходностейweekly_returns = returns.resample('W').agg(lambda x: (x + 1).prod() - 1)# Построение графиков еженедельных доходностейfig, ax = plt.subplots(len(indexes), figsize=(12, 8))for i in range(len(indexes)):    ax[i].plot(weekly_returns[indexes[i]])    ax[i].set_title(indexes[i])# Рассчет корреляции между индексамиcorr_matrix = weekly_returns.corr()# Построение тепловой карты корреляцийfig, ax = plt.subplots(figsize=(8, 6))im = ax.imshow(corr_matrix, cmap='coolwarm')ax.set_xticks(np.arange(len(indexes)))ax.set_yticks(np.arange(len(indexes)))ax.set_xticklabels(indexes)ax.set_yticklabels(indexes)plt.colorbar(im)# Рассчет и вывод средней доходности и стандартного отклоненияstats = pd.concat([weekly_returns.mean(), weekly_returns.std()], axis=1)stats.columns = ['Mean Return', 'Std Dev']print(stats)# Прогнозирование будущих значений индексовn_periods = 52  # Число периодов для прогнозированияX = np.arange(len(weekly_returns)).reshape(-1, 1)y = weekly_returns['^GSPC']model = LinearRegression()model.fit(X, y)future_X = np.arange(len(weekly_returns), len(weekly_returns) + n_periods).reshape(-1, 1)future_y = model.predict(future_X)# Построение графика прогнозируемых значенийfig, ax = plt.subplots(figsize=(8, 6))ax.plot(X, y, label='Historical Data')ax.plot(future_X, future_y, label='Forecast')ax.set_xlabel('Week')ax.set_ylabel('Return')ax.set_title('S&P 500 Forecast')ax.legend()plt.show()", "import pandas as pdclass Movie:    def __init__(self, title, genres, imdb_rating, runtime, year, director):        self.title = title        self.genres = genres        self.imdb_rating = imdb_rating        self.runtime = runtime        self.year = year        self.director = director    def __repr__(self):        return f\"{self.title} ({self.year}) - {self.genres} - {self.imdb_rating}/10\"class MovieDatabase:    def __init__(self, file_path):        self.movies = []        self.load_database(file_path)    def load_database(self, file_path):        df = pd.read_csv(file_path)        for i, row in df.iterrows():            movie = Movie(row[\"Title\"], row[\"Genres\"].split(\"|\"), row[\"IMDb Rating\"], row[\"Runtime (mins)\"], row[\"Year\"], row[\"Director\"])            self.movies.append(movie)    def filter_by_genre(self, genre):        filtered_movies = []        for movie in self.movies:            if genre in movie.genres:                filtered_movies.append(movie)        return filtered_movies    def filter_by_rating(self, min_rating):        filtered_movies = []        for movie in self.movies:            if movie.imdb_rating >= min_rating:                filtered_movies.append(movie)        return filtered_movies    def filter_by_year(self, min_year, max_year):        filtered_movies = []        for movie in self.movies:            if movie.year >= min_year and movie.year <= max_year:                filtered_movies.append(movie)        return filtered_movies    def get_top_rated_movies(self, limit):        sorted_movies = sorted(self.movies, key=lambda movie: movie.imdb_rating, reverse=True)        return sorted_movies[:limit]    def get_longest_movies(self, limit):        sorted_movies = sorted(self.movies, key=lambda movie: movie.runtime, reverse=True)        return sorted_movies[:limit]if __name__ == '__main__':    database = MovieDatabase(\"movies.csv\")    print(\"Welcome to MoviePicker!\")    print(\"Choose an option:\")    print(\"1. Filter movies by genre\")    print(\"2. Filter movies by rating\")    print(\"3. Filter movies by year\")    print(\"4. Get top rated movies\")    print(\"5. Get longest movies\")    choice = input(\"Enter your choice: \")    if choice == \"1\":        genre = input(\"Enter genre: \")        movies = database.filter_by_genre(genre)        print(f\"Found {len(movies)} movies:\")        for movie in movies:            print(movie)    elif choice == \"2\":        min_rating = float(input(\"Enter minimum rating: \"))        movies = database.filter_by_rating(min_rating)        print(f\"Found {len(movies)} movies:\")        for movie in movies:            print(movie)    elif choice == \"3\":        min_year = int(input(\"Enter minimum year: \"))        max_year = int(input(\"Enter maximum year: \"))        movies = database.filter_by_year(min_year, max_year)        print(f\"Found {len(movies)} movies:\")        for movie in movies:            print(movie)    elif choice == \"4\":        limit = int(input(\"Enter number of movies to show: \"))        movies = database.get_top_rated_movies(limit)        print", "from keras.optimizers import SGD# Создание оптимизатора SGD с моментом Нестероваsgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)# Компиляция модели с оптимизатором SGD с моментом Нестероваmodel.compile(optimizer=sgd, loss='categorical_crossentropy')# Обучение модели с оптимизатором SGD с моментом Нестероваmodel.fit(X_train, Y_train, validation_data=(X_val, Y_val), epochs=10, batch_size=64)", "import tflearn# Создание оптимизатора SGD с моментом Нестероваsgd = tflearn.optimizers.SGD(nesterov=True)# Компиляция модели с оптимизатором SGD с моментом Нестероваmodel.compile(optimizer=sgd, loss='categorical_crossentropy')# Обучение модели с оптимизатором SGD с моментом Нестероваmodel.fit(X_train, Y_train, validation_set=(X_val, Y_val), n_epoch=10, batch_size=64)"]},
    {"tag": "empty", "patterns": ["", "", ""]}
  ]
}